# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `faraday_middleware` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Faraday
  class << self
    def default_adapter; end
    def default_adapter=(adapter); end
    def default_connection; end
    def default_connection=(_arg0); end
    def default_connection_options; end
    def default_connection_options=(options); end
    def ignore_env_proxy; end
    def ignore_env_proxy=(_arg0); end
    def lib_path; end
    def lib_path=(_arg0); end
    def new(url = T.unsafe(nil), options = T.unsafe(nil), &block); end
    def require_lib(*libs); end
    def require_libs(*libs); end
    def respond_to_missing?(symbol, include_private = T.unsafe(nil)); end
    def root_path; end
    def root_path=(_arg0); end

    private

    def method_missing(name, *args, &block); end
  end
end

Faraday::FilePart = UploadIO
Faraday::METHODS_WITH_BODY = T.let(T.unsafe(nil), Array)
Faraday::METHODS_WITH_QUERY = T.let(T.unsafe(nil), Array)
Faraday::Parts = Parts

class Faraday::Request < ::Struct
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::AutoloadHelper

  def [](key); end
  def []=(key, value); end
  def headers=(hash); end
  def marshal_dump; end
  def marshal_load(serialised); end
  def method; end
  def params=(hash); end
  def to_env(connection); end
  def url(path, params = T.unsafe(nil)); end

  class << self
    def create(request_method); end
  end
end

Faraday::Request::OAuth = FaradayMiddleware::OAuth
Faraday::Request::OAuth2 = FaradayMiddleware::OAuth2

class Faraday::Response
  extend ::Forwardable
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::AutoloadHelper

  def initialize(env = T.unsafe(nil)); end

  def [](*args, &block); end
  def apply_request(request_env); end
  def body; end
  def env; end
  def finish(env); end
  def finished?; end
  def headers; end
  def marshal_dump; end
  def marshal_load(env); end
  def on_complete(&block); end
  def reason_phrase; end
  def status; end
  def success?; end
  def to_hash; end
end

Faraday::Response::Mashify = FaradayMiddleware::Mashify
Faraday::Response::ParseJson = FaradayMiddleware::ParseJson
Faraday::Response::ParseMarshal = FaradayMiddleware::ParseMarshal
Faraday::Response::ParseXml = FaradayMiddleware::ParseXml
Faraday::Response::ParseYaml = FaradayMiddleware::ParseYaml
Faraday::Response::Rashify = FaradayMiddleware::Rashify
Faraday::Timer = Timeout
Faraday::UploadIO = UploadIO
Faraday::VERSION = T.let(T.unsafe(nil), String)
module FaradayMiddleware; end

class FaradayMiddleware::Caching < ::Faraday::Middleware
  extend ::Forwardable

  def initialize(app, cache = T.unsafe(nil), options = T.unsafe(nil)); end

  def build_query(*args, &block); end
  def cache; end
  def cache_key(env); end
  def cache_on_complete(env); end
  def call(env); end
  def finalize_response(response, env); end
  def full_key?; end
  def params_to_ignore; end
  def parse_query(*args, &block); end
  def store_response_in_cache(key, response); end
end

FaradayMiddleware::Caching::CACHEABLE_STATUS_CODES = T.let(T.unsafe(nil), Array)

class FaradayMiddleware::Chunked < ::FaradayMiddleware::ResponseMiddleware
  def chunked_encoding?(headers); end
  def parse_response?(env); end
end

FaradayMiddleware::Chunked::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

class FaradayMiddleware::EncodeJson < ::Faraday::Middleware
  def call(env); end
  def encode(data); end
  def has_body?(env); end
  def match_content_type(env); end
  def process_request?(env); end
  def request_type(env); end
end

FaradayMiddleware::EncodeJson::CONTENT_TYPE = T.let(T.unsafe(nil), String)
FaradayMiddleware::EncodeJson::MIME_TYPE = T.let(T.unsafe(nil), String)
FaradayMiddleware::EncodeJson::MIME_TYPE_REGEX = T.let(T.unsafe(nil), Regexp)

class FaradayMiddleware::FollowRedirects < ::Faraday::Middleware
  def initialize(app, options = T.unsafe(nil)); end

  def call(env); end

  private

  def callback; end
  def clear_authorization_header(env, from_url, to_url); end
  def convert_to_get?(response); end
  def follow_limit; end
  def follow_redirect?(env, response); end
  def perform_with_redirection(env, follows); end
  def redirect_to_same_host?(from_url, to_url); end
  def safe_escape(uri); end
  def standards_compliant?; end
  def update_env(env, request_body, response); end
end

FaradayMiddleware::FollowRedirects::ALLOWED_METHODS = T.let(T.unsafe(nil), Set)
FaradayMiddleware::FollowRedirects::AUTH_HEADER = T.let(T.unsafe(nil), String)
FaradayMiddleware::FollowRedirects::ENV_TO_CLEAR = T.let(T.unsafe(nil), Set)
FaradayMiddleware::FollowRedirects::FOLLOW_LIMIT = T.let(T.unsafe(nil), Integer)
FaradayMiddleware::FollowRedirects::REDIRECT_CODES = T.let(T.unsafe(nil), Set)
FaradayMiddleware::FollowRedirects::URI_UNSAFE = T.let(T.unsafe(nil), Regexp)

class FaradayMiddleware::Gzip < ::Faraday::Middleware
  def brotli_inflate(body); end
  def call(env); end
  def inflate(body); end
  def raw_body(body); end
  def reset_body(env); end
  def uncompress_gzip(body); end

  class << self
    def optional_dependency(lib = T.unsafe(nil)); end
    def supported_encodings; end
  end
end

FaradayMiddleware::Gzip::ACCEPT_ENCODING = T.let(T.unsafe(nil), String)
FaradayMiddleware::Gzip::CONTENT_ENCODING = T.let(T.unsafe(nil), String)
FaradayMiddleware::Gzip::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
FaradayMiddleware::Gzip::SUPPORTED_ENCODINGS = T.let(T.unsafe(nil), String)

class FaradayMiddleware::Instrumentation < ::Faraday::Middleware
  def initialize(app, options = T.unsafe(nil)); end

  def call(env); end
end

class FaradayMiddleware::Mashify < ::Faraday::Response::Middleware
  def initialize(app = T.unsafe(nil), options = T.unsafe(nil)); end

  def mash_class; end
  def mash_class=(_arg0); end
  def parse(body); end

  class << self
    def mash_class; end
    def mash_class=(_arg0); end
  end
end

class FaradayMiddleware::MethodOverride < ::Faraday::Middleware
  def initialize(app, options = T.unsafe(nil)); end

  def call(env); end
  def rewrite_request(env, original_method); end
  def rewrite_request?(method); end
end

FaradayMiddleware::MethodOverride::HEADER = T.let(T.unsafe(nil), String)

class FaradayMiddleware::OAuth < ::Faraday::Middleware
  extend ::Forwardable

  def initialize(app, options); end

  def body_params(env); end
  def call(env); end
  def include_body_params?(env); end
  def oauth_header(env); end
  def oauth_options(env); end
  def parse_nested_query(*args, &block); end
  def sign_request?(env); end
  def signature_params(params); end
end

class FaradayMiddleware::OAuth2 < ::Faraday::Middleware
  extend ::Forwardable

  def initialize(app, token = T.unsafe(nil), options = T.unsafe(nil)); end

  def build_query(*args, &block); end
  def call(env); end
  def param_name; end
  def parse_query(*args, &block); end
  def query_params(url); end
  def token_type; end
end

FaradayMiddleware::OAuth2::AUTH_HEADER = T.let(T.unsafe(nil), String)
FaradayMiddleware::OAuth2::PARAM_NAME = T.let(T.unsafe(nil), String)
FaradayMiddleware::OAuth2::TOKEN_TYPE = T.let(T.unsafe(nil), String)
FaradayMiddleware::OAuth::AUTH_HEADER = T.let(T.unsafe(nil), String)
FaradayMiddleware::OAuth::CONTENT_TYPE = T.let(T.unsafe(nil), String)
FaradayMiddleware::OAuth::TYPE_URLENCODED = T.let(T.unsafe(nil), String)

module FaradayMiddleware::OptionsExtension
  def each; end
  def fetch(key, *args); end
  def preserve_raw; end
  def preserve_raw=(_arg0); end
  def to_hash; end
end

class FaradayMiddleware::ParseDates < ::Faraday::Response::Middleware
  def initialize(app, options = T.unsafe(nil)); end

  def call(env); end

  private

  def parse_dates!(value); end
end

FaradayMiddleware::ParseDates::ISO_DATE_FORMAT = T.let(T.unsafe(nil), Regexp)
class FaradayMiddleware::ParseJson < ::FaradayMiddleware::ResponseMiddleware; end

class FaradayMiddleware::ParseJson::MimeTypeFix < ::FaradayMiddleware::ResponseMiddleware
  def first_char(body); end
  def parse_response?(env); end
  def process_response(env); end
end

FaradayMiddleware::ParseJson::MimeTypeFix::BRACKETS = T.let(T.unsafe(nil), Array)
FaradayMiddleware::ParseJson::MimeTypeFix::MIME_TYPE = T.let(T.unsafe(nil), String)
FaradayMiddleware::ParseJson::MimeTypeFix::WHITESPACE = T.let(T.unsafe(nil), Array)
class FaradayMiddleware::ParseMarshal < ::FaradayMiddleware::ResponseMiddleware; end
class FaradayMiddleware::ParseXml < ::FaradayMiddleware::ResponseMiddleware; end
class FaradayMiddleware::ParseYaml < ::FaradayMiddleware::ResponseMiddleware; end

class FaradayMiddleware::RackCompatible
  def initialize(app, rack_handler, *args); end

  def call(env); end
  def finalize_response(env, rack_response); end
  def headers_to_rack(env); end
  def prepare_env(faraday_env); end
  def restore_env(rack_env); end
end

FaradayMiddleware::RackCompatible::NON_PREFIXED_HEADERS = T.let(T.unsafe(nil), Array)
class FaradayMiddleware::Rashify < ::FaradayMiddleware::Mashify; end

class FaradayMiddleware::RedirectLimitReached < ::Faraday::ClientError
  def initialize(response); end

  def response; end
end

class FaradayMiddleware::ResponseMiddleware < ::Faraday::Middleware
  def initialize(app = T.unsafe(nil), options = T.unsafe(nil)); end

  def call(environment); end
  def parse(body); end
  def parse_response?(env); end
  def preserve_raw?(env); end
  def process_response(env); end
  def process_response_type?(type); end
  def response_type(env); end

  class << self
    def define_parser(parser = T.unsafe(nil), &block); end
    def inherited(subclass); end
    def parser; end
    def parser=(_arg0); end
  end
end

FaradayMiddleware::ResponseMiddleware::CONTENT_TYPE = T.let(T.unsafe(nil), String)
